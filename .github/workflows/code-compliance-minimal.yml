name: Code Compliance (minimal)

on:
  pull_request:
    paths:
      - '**/*.kt'
      - '**/*.kts'
      - '**/*.java'
      - '**/*.js'
      - '**/*.ts'
      - '**/*.tsx'
      - '**/*.jsx'
      - '**/*.py'
      - '**/*.sh'
      - 'scripts/**'
      - '.github/workflows/code-compliance-minimal.yml'
  workflow_dispatch:
    inputs:
      run_reuse:         { description: 'Run REUSE (SPDX headers)', default: 'true' }
      run_sbom_licenses: { description: 'Build SBOM and license summary', default: 'true' }
      run_jscpd:        { description: 'Run code duplication (jscpd)', default: 'true' }
      jscpd_paths:      { description: 'Paths to scan (space-separated)', default: 'app-android feature-exam core-* scripts' }
      jscpd_min_tokens: { description: 'jscpd min tokens', default: '70' }
      jscpd_threshold:  { description: 'jscpd duplication % threshold (0-100)', default: '2' } # только для отчёта
      fail_on_jscpd:    { description: 'Fail job on duplication findings', default: 'false' }

jobs:
  compliance:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - name: Prepare reports dir
        run: mkdir -p reports

      - name: Install REUSE
        if: ${{ inputs.run_reuse == 'true' || github.event_name == 'pull_request' }}
        run: |
          python3 -m pip install --user reuse
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          reuse --version

      - name: REUSE lint (SPDX headers & LICENSE)
        if: ${{ inputs.run_reuse == 'true' || github.event_name == 'pull_request' }}
        run: |
          reuse lint | tee reports/reuse-lint.txt
          echo "Hint: для зависимостей Gradle рекомендуем отдельный PR с CashApp Licensee" | tee -a reports/reuse-lint.txt

      - name: Prepare sbom Gradle init script
        if: ${{ inputs.run_sbom_licenses == 'true' || github.event_name == 'pull_request' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p gradle reports/sbom/deps
          cat > gradle/sbom.init.gradle <<'GRADLE_EOF'
          import org.gradle.api.Project
          import org.gradle.api.artifacts.Configuration
          import org.gradle.api.attributes.*
          import java.util.concurrent.atomic.AtomicInteger

          // Extract runtime artifacts using lenient artifact views to avoid variant selection errors.
          static Set<File> collectArtifacts(Project p, Configuration cfg) {
            def files = [] as Set<File>
            def artifactTypeAttr = Attribute.of("artifactType", String)
            def libraryElementsAttr = Attribute.of("libraryElements", LibraryElements)
            def combos = [
              [artifactType: "jar", library: "jar"],
              [artifactType: "classes", library: "classes"],
              [artifactType: "android-classes", library: "android-classes"],
              [artifactType: "android-classes-jar", library: "android-classes-jar"],
              [artifactType: "aar", library: "aar"],
            ]

            def addFromView = { Closure attrsConfigurer ->
              def view = cfg.incoming.artifactView { v ->
                v.lenient true
                v.attributes { attrs -> attrsConfigurer.call(attrs) }
              }
              try {
                files.addAll(view.artifacts.artifactFiles.files)
              } catch (Throwable ignored) {
                // continue collecting
              }
            }

            combos.each { combo ->
              addFromView { a -> a.attribute(artifactTypeAttr, combo.artifactType) }
              try {
                def lib = p.objects.named(LibraryElements, combo.library)
                addFromView { a -> a.attribute(libraryElementsAttr, lib) }
                addFromView { a ->
                  a.attribute(artifactTypeAttr, combo.artifactType)
                  a.attribute(libraryElementsAttr, lib)
                }
              } catch (Throwable ignored) {
                // libraryElements value may not exist; artifactType-only view already attempted
              }
            }

            try {
              files.addAll(cfg.files)
            } catch (Throwable ignored) {
              // ignore direct resolution failures from ambiguous variants
            }

            return files
          }

          gradle.projectsEvaluated {
            def root = gradle.rootProject
            def rootDir = root.projectDir
            def allProviders = []
            def totalCounter = new AtomicInteger(0)

            root.allprojects.each { prj ->
              def resolvables = prj.configurations.findAll {
                it.canBeResolved && it.name ==~ /(?i).*(release|debug)?(runtime|compile)Classpath$/
              }
              resolvables.each { cfg ->
                def safe = prj.path == ':' ? 'root' : prj.path.replace(':','_').replaceFirst('^_','')
                def outDir = new File(rootDir, "reports/sbom/deps/${safe}/${cfg.name}")
                def tn = "sbomCopy_${safe}_${cfg.name}"
                def tp = prj.tasks.register(tn) {
                  doLast {
                    def files = collectArtifacts(prj, cfg)
                    def existing = files.findAll { it?.exists() }
                    if (!existing.isEmpty()) {
                      prj.copy { spec ->
                        spec.from(existing)
                        spec.into(outDir)
                      }
                    }
                    println "[sbom][${safe}:${cfg.name}] copied=" + existing.size()
                    totalCounter.addAndGet(existing.size())
                  }
                }
                allProviders << tp
              }
            }

            root.tasks.register('sbomCopyAll') {
              dependsOn allProviders
              doLast {
                def total = totalCounter.get()
                println "[sbom] TOTAL artifacts copied=" + total
                if (total == 0) {
                  println "[sbom] No artifacts copied. Known resolvable configs by module:"
                  root.allprojects.each { prj ->
                    def cfgs = prj.configurations.findAll {
                      it.canBeResolved && it.name ==~ /(?i).*(release|debug)?(runtime|compile)Classpath$/
                    }
                    if (!cfgs.isEmpty()) {
                      println "  - ${prj.path}: " + (cfgs*.name.join(', '))
                    }
                  }
                  throw new GradleException("SBOM: zero artifacts copied; check configuration filters")
                }
              }
            }
          }
          GRADLE_EOF

      - name: Copy resolved Gradle dependencies (no build script changes)
        if: ${{ inputs.run_sbom_licenses == 'true' || github.event_name == 'pull_request' }}
        shell: bash
        run: |
          set -euo pipefail
          ./gradlew -q -I gradle/sbom.init.gradle :sbomCopyAll
          echo "[sbom] deps dir size:"; du -sh reports/sbom/deps || true
          echo "[sbom] files copied:" $(find reports/sbom/deps -type f \( -name '*.jar' -o -name '*.aar' -o -name '*.zip' \) | wc -l || echo 0)

      - name: Gradle dependencies snapshot (diagnostic)
        if: ${{ inputs.run_sbom_licenses == 'true' || github.event_name == 'pull_request' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p reports
          ./gradlew -q :app-android:dependencies --configuration releaseRuntimeClasspath > reports/gradle-deps.txt || true

      - name: Install Syft (SBOM)
        if: ${{ inputs.run_sbom_licenses == 'true' || github.event_name == 'pull_request' }}
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b .
          ./syft version

      - name: Generate SBOM (source tree)
        if: ${{ inputs.run_sbom_licenses == 'true' || github.event_name == 'pull_request' }}
        run: ./syft dir:. -o cyclonedx-json=reports/sbom-source.json

      - name: Generate SBOM (resolved deps)
        if: ${{ inputs.run_sbom_licenses == 'true' || github.event_name == 'pull_request' }}
        run: |
          ./syft dir:reports/sbom/deps -o cyclonedx-json=reports/sbom-deps.json || echo '{"components":[]}' > reports/sbom-deps.json

      - name: Merge SBOM (source + deps) & license summaries
        if: ${{ inputs.run_sbom_licenses == 'true' || github.event_name == 'pull_request' }}
        run: |
          jq -s '{
            bomFormat: "CycloneDX",
            specVersion: "1.5",
            version: 1,
            components: (.[0].components + .[1].components) | unique_by(.name + ":" + (.version // "")),
            metadata: (.[0].metadata // null)
          }' reports/sbom-source.json reports/sbom-deps.json > reports/sbom-cyclonedx.json
          comps=$(jq '.components|length' reports/sbom-cyclonedx.json)
          echo "[sbom] merged components=${comps}"
          if [ "$comps" -eq 0 ]; then
            echo "::error::SBOM merge produced zero components"
            exit 1
          fi
          jq -r '[ .components[]? | { name, version, licenses: ((.licenses // []) | map(.license.id // .expression)) } ]' \
            reports/sbom-cyclonedx.json > reports/deps-licenses.json
          jq -r '[ .components[]? | (.licenses // [] | map(.license.id // .expression)[])? ] | group_by(.) | map({license: .[0], count: length})' \
            reports/sbom-cyclonedx.json > reports/deps-licenses-summary.json
          echo "Top licenses:" && jq -r '.[:10]' reports/deps-licenses-summary.json
          {
            echo "## Dependency license summary"
            echo
            echo "- components=$comps"
            echo "- Components discovered: $comps"
            echo "- Hint: для зависимостей Gradle рекомендуем отдельный PR с CashApp Licensee"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: jscpd (code duplication)
        if: ${{ inputs.run_jscpd == 'true' || github.event_name == 'pull_request' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p reports/jscpd
          npx -y jscpd@3.5.10 \
            --pattern "{app-android,feature-exam,core-*,scripts}/**/*.{kt,kts,java,js,ts,tsx,jsx,xml,md,py,sh}" \
            --exclude "**/build/**" \
            --exclude "**/test/**" \
            --exclude "**/.*/**" \
            --min-tokens "${{ inputs.jscpd_min_tokens || '70' }}" \
            --reporters "console,html,json" \
            --output "reports/jscpd" | tee reports/jscpd/console.txt
        continue-on-error: ${{ inputs.fail_on_jscpd != 'true' }}

      - name: Emit Markdown summary
        run: node scripts/cc-summary.mjs

      - name: Upload compliance reports
        uses: actions/upload-artifact@v4
        with:
          name: code-compliance-reports
          path: |
            reports/gradle-deps.txt
            reports/sbom-source.json
            reports/sbom-deps.json
            reports/sbom-cyclonedx.json
            reports/deps-licenses.json
            reports/deps-licenses-summary.json
            reports/jscpd/**
            reports/code-compliance-summary.md
          if-no-files-found: warn
